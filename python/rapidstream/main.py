import click
import json
import os
import subprocess
from pyverilog.vparser.parser import parse

from rapidstream.parser.tapa_parser import parse_tapa_output_rtl
from rapidstream.opt import islandize_vertices
from rapidstream.util import setup_logging, create_xo, dump_files
from rapidstream.backend.split import annotate_io_orientation
from rapidstream.backend.synth import setup_island_synth
from rapidstream.backend.place import setup_island_init_placement
from rapidstream.backend.anchor_place import setup_anchor_placement_inner, collect_anchor_placement_result
from rapidstream.backend.island_place_opt import setup_island_placement_opt_inner
from rapidstream.backend.overlay import generate_overlay_inner
from rapidstream.backend.route import setup_island_route_inner
from rapidstream.backend.setup_nested_dfx import setup_nested_dfx_inner
from rapidstream.backend.setup_abs_shell import setup_abs_shell

@click.command()
@click.option(
  '--top-rtl-path',
  required=True,
  help='Path to the top-level RTL generated by TAPA.'
)
@click.option(
  '--post-floorplan-config-path',
  required=True,
  help='Path to the configuration file generated by AutoBridge.'
)
@click.option(
  '--top-name',
  required=True,
  help='Name of the top function.'
)
@click.option(
  '--xo-path',
  required=True,
  help='the xo file created by tapa.'
)
@click.option(
  '--tapa-hdl-dir',
  required=True,
)
@click.option(
  '--output-dir',
  required=True,
)
@click.option(
  '--dummy-abs-shell-dir',
  required=True,
  help="The dummy abstract shell for each island, "
       "used for placement only, generated from the hmss shell"
)
@click.option(
  '--hmss-shell-path',
  required=True,
  help="The shell that includes the PCIe, DMA and HMSS"
)
def main(
  top_rtl_path: str,
  post_floorplan_config_path: str,
  top_name: str,
  xo_path: str,
  tapa_hdl_dir: str,
  output_dir: str,
  dummy_abs_shell_dir: str,
  hmss_shell_path: str,
):
  """Entry point for RapidStream that targets TAPA"""
  tapa_hdl_dir = os.path.abspath(tapa_hdl_dir)
  output_dir = os.path.abspath(output_dir)
  os.makedirs(output_dir, exist_ok=True)

  setup_logging()

  config = json.load(open(post_floorplan_config_path, 'r'))
  ast_root, _ = parse([top_rtl_path])

  parse_tapa_output_rtl(config, ast_root)

  open(f'{output_dir}/pre_rapidstream.json', 'w').write(json.dumps(config, indent=2))

  name_to_file, name_to_dummy_file = islandize_vertices(config, top_name, use_anchor_wrapper=True)
  create_xo(top_name, xo_path, name_to_file, output_dir, xo_suffix = '_rapidstream', temp_dir='temp_orig_xo')
  create_xo(top_name, xo_path, name_to_dummy_file, output_dir, xo_suffix = '_rapidstream_dummy', temp_dir='temp_dummy_xo')
  dump_files(name_to_file, f'{output_dir}/wrapper_rtl')
  dump_files(name_to_dummy_file, f'{output_dir}/dummy_wrapper_rtl')

  open(f'{output_dir}/rapidstream.json', 'w').write(json.dumps(config, indent=2))

  annotate_io_orientation(config)

  open(f'{output_dir}/rapidstream_with_io_orientation.json', 'w').write(json.dumps(config, indent=2))

  setup_island_synth(
    config,
    f'{output_dir}/backend/synth',
    tapa_hdl_dir,
    f'{output_dir}/wrapper_rtl'
  )

  setup_island_init_placement(
    config,
    f'{output_dir}/backend/synth',
    f'{output_dir}/backend/init_placement',
    dummy_abs_shell_dir,
    top_name,
  )

  # pr subdivide the user region into islands
  setup_nested_dfx_inner(
    config,
    f'{output_dir}/backend/nested_dfx',
    f'{output_dir}/dummy_wrapper_rtl',
    top_name,
    hmss_shell_path,
  )
  nestd_dfx_process = detached_run(
    f'cd {output_dir}/backend/nested_dfx; vivado -mode batch -source {output_dir}/backend/nested_dfx/setup_nested_dfx.tcl'
  )

  # invoke parallel synthesis
  os.system(f'parallel < {output_dir}/backend/synth/parallel.txt')

  # invoke parallel placement
  os.system(f'parallel < {output_dir}/backend/init_placement/parallel.txt')

  # invoke parallel anchor placement
  setup_anchor_placement_inner(config, f'{output_dir}/backend/init_placement', f'{output_dir}/backend/anchor_placement')
  os.system(f'parallel < {output_dir}/backend/anchor_placement/parallel.txt')
  collect_anchor_placement_result(f'{output_dir}/backend/anchor_placement')

  setup_island_placement_opt_inner(
    config,
    f'{output_dir}/backend/init_placement',
    f'{output_dir}/backend/anchor_placement',
    f'{output_dir}/backend/island_place_opt',
    top_name,
  )
  island_place_opt_process = detached_run(f'parallel < {output_dir}/backend/island_place_opt/parallel.txt')

  # the nested dfx dcp should be ready before overlay generation
  nestd_dfx_process.wait()

  # overlap the overlay gen with island re-placement
  generate_overlay_inner(
    f'{output_dir}/backend/overlay_generation',
    top_name,
    f'{output_dir}/backend/anchor_placement',
    f'{output_dir}/backend/nested_dfx/after_pr_subdivide.dcp',
  )
  os.system(f'cd {output_dir}/backend/overlay_generation; vivado -mode batch -source gen_overlay.tcl')

  # detached bitstream generation for overlay
  gen_overlay_bistream_process = detached_run(
    f'cd {output_dir}/backend/overlay_generation; vivado -mode batch -source gen_overlay_bitstream.tcl'
  )

  # generate abstract shell after overlay is generated
  setup_abs_shell(
    config,
    f'{output_dir}/backend/overlay_generation',
    f'{output_dir}/backend/abs_shell',
    top_name,
  )
  os.system(f'parallel < {output_dir}/backend/abs_shell/parallel.txt')

  island_place_opt_process.wait()

  # final island routing
  setup_island_route_inner(
    config,
    f'{output_dir}/backend/abs_shell',
    f'{output_dir}/backend/island_route',
    f'{output_dir}/backend/island_place_opt',
    top_name,
  )
  os.system(f'parallel < {output_dir}/backend/island_route/parallel.txt')

  # wait until the bitstream for the overlay is generated
  gen_overlay_bistream_process.wait()


def detached_run(cmd: str) -> subprocess.Popen:
  return subprocess.Popen([cmd],
    shell=True,
    stdout=subprocess.DEVNULL,
    stderr=subprocess.DEVNULL,
  )


if __name__ == '__main__':
  main()
