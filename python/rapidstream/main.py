import click
import json
import os
import subprocess
from pyverilog.vparser.parser import parse

from rapidstream.parser.tapa_parser import parse_tapa_output_rtl
from rapidstream.opt import islandize_vertices
from rapidstream.util import setup_logging, create_xo, dump_files
from rapidstream.backend.split import annotate_io_orientation
from rapidstream.backend.synth import setup_island_synth
from rapidstream.backend.place import setup_island_init_placement
from rapidstream.backend.anchor_place import setup_anchor_placement_inner, collect_anchor_placement_result
from rapidstream.backend.island_place_opt import setup_island_placement_opt_inner
from rapidstream.backend.overlay import generate_overlay_inner
from rapidstream.backend.route import setup_island_route
from rapidstream.backend.setup_nested_dfx import setup_nested_dfx_inner
from rapidstream.backend.setup_abs_shell import setup_abs_shell

@click.command()
@click.option(
  '--top-rtl-path',
  required=True,
  help='Path to the top-level RTL generated by TAPA.'
)
@click.option(
  '--post-floorplan-config-path',
  required=True,
  help='Path to the configuration file generated by AutoBridge.'
)
@click.option(
  '--top-name',
  required=True,
  help='Name of the top function.'
)
@click.option(
  '--xo-path',
  required=True,
  help='the xo file created by tapa.'
)
@click.option(
  '--tapa-hdl-dir',
  required=True,
)
@click.option(
  '--output-dir',
  required=True,
)
@click.option(
  '--dummy-abs-shell-dir',
  required=True,
  help="The dummy abstract shell for each island, "
       "used for placement only, generated from the hmss shell"
)
@click.option(
  '--hmss-shell-path',
  required=True,
  help="The shell that includes the PCIe, DMA and HMSS"
)
@click.option(
  '--re-place-before-routing',
  is_flag=True,
  required=False,
  default=False,
)
@click.option(
  '--re-place-after-anchor-place',
  is_flag=True,
  required=False,
  default=False,
)
def main(
  top_rtl_path: str,
  post_floorplan_config_path: str,
  top_name: str,
  xo_path: str,
  tapa_hdl_dir: str,
  output_dir: str,
  dummy_abs_shell_dir: str,
  hmss_shell_path: str,
  re_place_before_routing: bool,
  re_place_after_anchor_place: bool,
):
  """Entry point for RapidStream that targets TAPA"""
  tapa_hdl_dir = os.path.abspath(tapa_hdl_dir)
  output_dir = os.path.abspath(output_dir)
  dummy_abs_shell_dir = os.path.abspath(dummy_abs_shell_dir)
  hmss_shell_path = os.path.abspath(hmss_shell_path)

  os.makedirs(output_dir, exist_ok=True)

  setup_logging()

  config = json.load(open(post_floorplan_config_path, 'r'))
  ast_root, _ = parse([top_rtl_path])

  parse_tapa_output_rtl(config, ast_root)

  open(f'{output_dir}/pre_rapidstream.json', 'w').write(json.dumps(config, indent=2))

  name_to_file, name_to_dummy_file = islandize_vertices(config, top_name, use_anchor_wrapper=True)
  create_xo(top_name, xo_path, name_to_file, output_dir, xo_suffix = '_rapidstream', temp_dir='temp_orig_xo')
  create_xo(top_name, xo_path, name_to_dummy_file, output_dir, xo_suffix = '_rapidstream_dummy', temp_dir='temp_dummy_xo')
  dump_files(name_to_file, f'{output_dir}/wrapper_rtl')
  dump_files(name_to_dummy_file, f'{output_dir}/dummy_wrapper_rtl')

  open(f'{output_dir}/rapidstream.json', 'w').write(json.dumps(config, indent=2))

  annotate_io_orientation(config)

  open(f'{output_dir}/rapidstream_with_io_orientation.json', 'w').write(json.dumps(config, indent=2))

  SYNTH_DIR = f'{output_dir}/backend/synth'
  INIT_PLACE_DIR = f'{output_dir}/backend/init_placement'
  NEST_DFX_DIR = f'{output_dir}/backend/nested_dfx'
  ANCHOR_PLACE_DIR = f'{output_dir}/backend/anchor_placement'
  PLACE_OPT_DIR = f'{output_dir}/backend/island_place_opt'
  OVERLAY_DIR = f'{output_dir}/backend/overlay_generation'
  ROUTE_DIR = f'{output_dir}/backend/island_route'
  ABS_SHELL_DIR = f'{output_dir}/backend/abs_shell'

  setup_island_synth(
    config,
    SYNTH_DIR,
    tapa_hdl_dir,
    f'{output_dir}/wrapper_rtl'
  )

  setup_island_init_placement(
    config,
    SYNTH_DIR,
    INIT_PLACE_DIR,
    dummy_abs_shell_dir,
    top_name,
  )

  # pr subdivide the user region into islands
  setup_nested_dfx_inner(
    config,
    NEST_DFX_DIR,
    f'{output_dir}/dummy_wrapper_rtl',
    top_name,
    hmss_shell_path,
  )
  nestd_dfx_process = detached_run(
    f'cd {NEST_DFX_DIR}; vivado -mode batch -source {NEST_DFX_DIR}/setup_nested_dfx.tcl'
  )

  # invoke parallel synthesis
  os.system(f'parallel < {SYNTH_DIR}/parallel.txt')

  # invoke parallel placement
  os.system(f'parallel < {INIT_PLACE_DIR}/parallel.txt')

  # invoke parallel anchor placement
  setup_anchor_placement_inner(config, INIT_PLACE_DIR, ANCHOR_PLACE_DIR)
  os.system(f'parallel < {ANCHOR_PLACE_DIR}/parallel.txt')
  collect_anchor_placement_result(ANCHOR_PLACE_DIR)

  setup_island_placement_opt_inner(
    config,
    INIT_PLACE_DIR,
    ANCHOR_PLACE_DIR,
    PLACE_OPT_DIR,
    top_name,
    rerun_placement = re_place_after_anchor_place,
  )
  island_place_opt_process = detached_run(f'parallel < {PLACE_OPT_DIR}/parallel.txt')

  # the nested dfx dcp should be ready before overlay generation
  nestd_dfx_process.wait()

  # overlap the overlay gen with island re-placement
  generate_overlay_inner(
    OVERLAY_DIR,
    top_name,
    ANCHOR_PLACE_DIR,
    f'{NEST_DFX_DIR}/after_pr_subdivide.dcp',
  )
  os.system(f'cd {OVERLAY_DIR}; vivado -mode batch -source gen_overlay.tcl')

  # detached bitstream generation for overlay
  gen_overlay_bistream_process = detached_run(
    f'cd {OVERLAY_DIR}; vivado -mode batch -source gen_overlay_bitstream.tcl'
  )

  # optimize the partition pin
  os.system(f'java com.xilinx.rapidwright.rwroute.AnchorRegRouterFull {OVERLAY_DIR}/overlay.dcp {OVERLAY_DIR}/rw_update_partpin.tcl')

  # generate abstract shell after overlay is generated
  setup_abs_shell(
    config,
    OVERLAY_DIR,
    ABS_SHELL_DIR,
    top_name,
  )
  os.system(f'parallel < {ABS_SHELL_DIR}/parallel.txt')

  island_place_opt_process.wait()

  # final island routing
  setup_island_route(
    config,
    ABS_SHELL_DIR,
    ROUTE_DIR,
    PLACE_OPT_DIR,
    top_name,
    re_place_before_routing = re_place_before_routing
  )
  os.system(f'parallel < {ROUTE_DIR}/parallel.txt')

  # wait until the bitstream for the overlay is generated
  gen_overlay_bistream_process.wait()


def detached_run(cmd: str) -> subprocess.Popen:
  return subprocess.Popen([cmd],
    shell=True,
    stdout=subprocess.DEVNULL,
    stderr=subprocess.DEVNULL,
  )


if __name__ == '__main__':
  main()
